#!/usr/bin/env python3

import json
import signal
import subprocess
import time
import urllib.request

from pathlib import Path
from collections import deque
from threading import Thread

import xmltodict

import gi
gi.require_version('Gtk', '3.0')  # noqa
gi.require_version('AppIndicator3', '0.1')  # noqa
gi.require_version('Notify', '0.7')  # noqa
from gi.repository import Gtk, AppIndicator3, Notify

from node_tools.helper_funcs import get_runtimedir


APPINDICATOR_ID = 'fpndindicator'
state_file = Path(get_runtimedir()).joinpath('fpnd.state')


def get_state_icon(state):
    """
    Look up the state msg and return the icon name.
    """
    state_dict = {
        'CONNECTED': 'network-vpn-symbolic',
        'WAITING': 'network-vpn-acquiring-symbolic',
        'CONFIG': 'network-vpn-no-route-symbolic',
        'ERROR': 'network-error-symbolic',
        'STARTING': 'network-idle-symbolic',
        'NONE': 'network-offline-symbolic'
    }
    return state_dict.get(state, state_dict['NONE'])


def get_status(filename, n=1):
    """
    Return the last n lines of the status file in a deque.
    """
    try:
        with open(filename) as f:
            return deque(f, n)
    except Exception as exc:
        print('State file error: {}'.format(exc))


def fetch_geoip():
    """
    Fetch location info from ubuntu.com geoip server and transform the
    xml payload to json.
    """
    request = urllib.request.Request('https://geoip.ubuntu.com/lookup')
    response = urllib.request.urlopen(request)
    payload = xmltodict.parse(response.read())
    return json.dumps(payload, indent=4, separators=(',', ': '))


def fetch_joke():
    """
    Fetch a random joke from the nerdy category.
    """
    request = urllib.request.Request('http://api.icndb.com/jokes/random?limitTo=[nerdy]')
    response = urllib.request.urlopen(request)
    joke = json.loads(response.read())['value']['joke']
    return joke


def run_service_cmd(action='is-active'):
    """
    Run systemctl command on fpnd service.

    :param action: one of <start|stop>
    :return: cmd result or empty str
    """

    result = ''
    actions = ['start', 'stop', 'status', 'is-active']
    svc_list = ['pkexec', 'systemctl']
    act_list = [action, 'fpnd.service']

    if Path('/sbin/openrc').is_file():
        if action == 'is-active':
            action = 'status'
        svc_list = ['pkexec', '/sbin/openrc', '-s']
        act_list = ['fpnd', action]
    cmd = svc_list + act_list

    if action in actions:
        print('Running {}'.format(cmd))
    else:
        msg = 'Invalid action: {}'.format(action)
        print(msg)
        return result

    try:
        proc = subprocess.Popen(cmd,
                                stderr=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                shell=False)

        out, err = proc.communicate()

        if err:
            print('run_service_cmd err result: {}'.format(err.decode().strip()))
            result = err.decode()
        else:
            result = out.decode()
            print('{} result: {}'.format(action, out.decode().strip()))

    except Exception as exc:
        print('run_service_cmd exception: {}'.format(exc))

    return result


class Indicator():
    def __init__(self):
        self.app_id = APPINDICATOR_ID
        icon_name = get_state_icon('NONE')
        self.indicator = AppIndicator3.Indicator.new(
            self.app_id,
            icon_name,
            AppIndicator3.IndicatorCategory.APPLICATION_STATUS)

        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
        # self.indicator.set_attention_icon_full('indicator-messages-new',
        #                                            'State update')
        self.indicator.set_menu(self.create_menu())
        # setup the state updater thread
        self.update = Thread(target=self.check_for_new_state)
        self.update.setDaemon(True)
        self.update.start()

    def check_for_new_state(self):
        """
        Check for new state msg and update icon if new.
        """
        old_state = 'NONE'
        guide = '999999999'

        while True:
            time.sleep(1)
            if state_file.exists():
                msg_queue = get_status(str(state_file))
                new_state = msg_queue.pop().strip()
            # if there is a change in state, update the icon
            if old_state != new_state:
                icon_name = get_state_icon(new_state)
                self.indicator.set_icon_full(icon_name, new_state)
                # Notify.Notification.new(new_state, None, None).show()
                # note the second label arg should be the longest possible label str
                self.indicator.set_label(new_state.format().center(9), guide)
            old_state = new_state

    def create_menu(self):
        menu = Gtk.Menu()
        item_start = Gtk.MenuItem(label='Start daemon')
        item_start.connect('activate', self.startd)
        menu.append(item_start)

        item_stop = Gtk.MenuItem(label='Stop daemon')
        item_stop.connect('activate', self.stopd)
        menu.append(item_stop)

        item_status = Gtk.MenuItem(label='Get daemon status')
        item_status.connect('activate', self.statusd)
        menu.append(item_status)

        item_geoip = Gtk.MenuItem(label='Get geoip')
        item_geoip.connect('activate', self.geoip)
        menu.append(item_geoip)

        item_joke = Gtk.MenuItem(label='Joke')
        item_joke.connect('activate', self.joke)
        menu.append(item_joke)

        item_separator = Gtk.SeparatorMenuItem()
        menu.append(item_separator)

        item_quit = Gtk.MenuItem(label='Quit')
        item_quit.connect('activate', self.stop)
        menu.append(item_quit)

        menu.show_all()
        return menu

    def stop(self, source):
        Notify.uninit()
        Gtk.main_quit()

    def joke(self, source):
        Notify.Notification.new("Joke", fetch_joke(), None).show()

    def geoip(self, source):
        Notify.Notification.new("Geoip", fetch_geoip(), None).show()

    def startd(self, source):
        svc_msg = run_service_cmd(action='start')
        if not svc_msg:
            svc_msg = 'Starting...'
        Notify.Notification.new("Daemon status", svc_msg, None).show()

    def statusd(self, source):
        svc_msg = run_service_cmd()
        Notify.Notification.new("Daemon status", svc_msg, None).show()

    def stopd(self, source):
        svc_msg = run_service_cmd(action='stop')
        if not svc_msg:
            svc_msg = 'Stopping...'
        Notify.Notification.new("Daemon status", svc_msg, None).show()


def main():
    Indicator()
    Notify.init(APPINDICATOR_ID)
    Gtk.main()


if __name__ == "__main__":
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    main()
